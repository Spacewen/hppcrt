
<!-- Source code generation phase is handled by an ANT script, it's simply much easier to do it from ANT. -->

<project name="hppc" default="-dummy">

    <property name="project.build.directory" location="target" />

    <!-- Exclude tests from generation. -->
    <patternset id="patterns.exclude.tests">
        <exclude name="**/*Benchmark*" />
        <exclude name="**/*Test*" />
        <exclude name="**/RequireAssertionsRule*" />
        <exclude name="com/carrotsearch/tests/**" />
    </patternset>
    
    <!-- Exclude javadoc resources. -->
    <patternset id="patterns.exclude.docfiles">
        <exclude name="**/doc-files/**" />
    </patternset>

    <!-- An empty filter. -->
    <filtermapper id="filter.empty">
    </filtermapper>

    <!-- Macros for the preprocessor. -->

    <macrodef name="apply.filter">
        <attribute name="filter1" />
        <attribute name="filter2" default="filter.empty" />
        <attribute name="filter3" default="filter.empty" />
        <attribute name="filter4" default="filter.empty" />
        <attribute name="fileset" />
        <attribute name="todir" />

        <sequential>
            <copy todir="@{todir}" encoding="UTF-8" filtering="true" overwrite="true">
                <path refid="@{fileset}" />
                <mapper>
                    <chainedmapper>
                        <filtermapper refid="@{filter1}" />
                        <filtermapper refid="@{filter2}" />
                        <filtermapper refid="@{filter3}" />
                        <filtermapper refid="@{filter4}" />
                    </chainedmapper>
                </mapper>
                <filterchain refid="@{filter1}" />
                <filterchain refid="@{filter2}" />
                <filterchain refid="@{filter3}" />
                <filterchain refid="@{filter4}" />
            </copy>
        </sequential>
    </macrodef>

    <macrodef name="declare.filter.common">
        <attribute name="filterName" />

        <sequential>
            <filtermapper id="@{filterName}">
                <!-- intrinsic:final → final -->
                <replaceregex byline="false" flags="gmi" 
                    pattern="/\*\s*intrinsic:final\s*\*/" 
                    replace=" final " />

                <!-- /* replaceIf:primitive [...] */ ... /* end:replaceIf */ → 
                     [...] (comment block content only) -->
                <replaceregex byline="false" flags="gms"
                    pattern="(?:/\*\s*)(?:replaceIf:primitive\s)(.+?)(\*/)(.+?)(end:replaceIf)(\s*\*/)" 
                    replace="/* replaceIf:applied. */ \1 /* end */" />

                <!-- /* removeIf:primitive ... end:removeIf */ → (removed) -->
                <replaceregex byline="false" flags="gms"
                    pattern="(/\*\s*)(removeIf:primitive\s)(.+?)(end:removeIf)(\s*\*/)" 
                    replace="/* removeIf:applied. */" />
            </filtermapper>
        </sequential>
    </macrodef>

    <macrodef name="declare.filter.ktype">
        <attribute name="filterName" />
        <attribute name="KType" />
        <attribute name="UKType" />

        <sequential>
            <filtermapper id="@{filterName}">
                <!-- intrinsic:ktypecast → (KType) -->
                <replaceregex byline="false" flags="gm"
                    pattern="/\*\s*intrinsic:ktypecast\s*\*/" 
                    replace=" (@{KType}) " />
    
                <!-- /* replaceIf:primitiveKType [...] */ ... /* end:replaceIf */ → 
                     [...] (comment block content only) -->
                <replaceregex byline="false" flags="gms"
                    pattern="(?:/\*\s*)(?:replaceIf:primitiveKType)(.+?)(\*/)(.+?)(end:replaceIf)(\s*\*/)" 
                    replace="/* replaceIf:applied. */ \1 /* end */" />
    
                <!-- /* removeIf:primitiveKType ... end:removeIf */ → (removed) -->
                <replaceregex byline="false" flags="gms"
                    pattern="(/\*\s*)(removeIf:primitiveKType\s)(.+?)(end:removeIf)(\s*\*/)" 
                    replace="/* removeIf:applied. */" />
    
                <!-- Intrinsics.newKTypeArray(size) → new KType [size] -->
                <replaceregex byline="false" flags="gmi"
                    pattern="(?:Intrinsics\s*\.)(?:&lt;[^&gt;]+&gt;)?(?:\s*newKTypeArray)(?:\()((\s|.)+?)(?:\))" 
                    replace="new @{KType} [\1]" />
    
                <!-- Intrinsics.defaultKTypeValue() → ((KType) 0) -->
                <replaceregex byline="false"  flags="gmi"
                    pattern="(Intrinsics\s*\.)(&lt;[^&gt;]+&gt;)?(\s*)defaultKTypeValue\(\)" 
                    replace="((@{KType}) 0)" />
    
                <replacestring from="UKType"        to="@{UKType}" />
                <replacestring from="KType"         to="@{KType}" />
            </filtermapper>
        </sequential>
    </macrodef>

    <macrodef name="declare.filter.vtype">
        <attribute name="filterName" />
        <attribute name="VType" />  <!-- Primitive type. -->
    	<attribute name="UVType" /> <!-- Uppercase (boxed) type. -->

        <sequential>
            <filtermapper id="@{filterName}">
                <!-- intrinsic:vtypecast → (VType) -->
                <replaceregex byline="false" flags="gm"
                    pattern="/\*\s*intrinsic:vtypecast\s*\*/" 
                    replace=" (@{VType}) " />
    
                <!-- /* replaceIf:primitiveVType [...] */ ... /* end:replaceIf */ → 
                     [...] (comment block content only) -->
                <replaceregex byline="false" flags="gms"
                    pattern="(?:/\*\s*)(?:replaceIf:primitiveVType)(.+?)(\*/)(.+?)(end:replaceIf)(\s*\*/)" 
                    replace="/* replaceIf:applied. */ \1 /* end */" />

                <!-- /* removeIf:primitiveVType ... end:removeIf */ → (removed) -->
                <replaceregex byline="false" flags="gms"
                    pattern="(/\*\s*)(removeIf:primitiveVType\s)(.+?)(end:removeIf)(\s*\*/)" 
                    replace="/* removeIf:applied. */" />
    
                <!-- Intrinsics.newVTypeArray(size) → new VType [size] -->
                <replaceregex byline="false" flags="gmi"
                    pattern="(?:Intrinsics\s*\.\s*)?(?:newVTypeArray)(?:\()((\s|.)+?)(?:\))" 
                    replace="new @{VType} [\1]" />
    
                <!-- Intrinsics.defaultVTypeValue() → ((VType) 0) -->
                <replaceregex byline="false"  flags="gmi"
                    pattern="(Intrinsics\s*\.)(&lt;[^&gt;]+&gt;)?(\s*)defaultVTypeValue\(\)" 
                    replace="((@{VType}) 0)" />
    
            	<replacestring from="UVType"        to="@{UVType}" />
                <replacestring from="VType"         to="@{VType}" />
            </filtermapper>
        </sequential>
    </macrodef>
    
    <macrodef name="preprocess.KType">
        <attribute name="KType" />  <!-- Primitive type. -->
        <attribute name="UKType" /> <!-- Uppercase (boxed) type. -->
        <attribute name="fileset" />
        <attribute name="todir" />

        <sequential>
            <declare.filter.common filterName="filter.common.@{KType}" />
            <declare.filter.ktype  filterName="filter.ktype.@{KType}" KType="@{KType}" UKType="@{UKType}" />

            <filtermapper id="filter.specific.@{KType}">
                <!-- Replace template class declarations in tests and benchmarks. -->
                <replaceregex byline="false" flags="gmi" 
                    pattern="(?:Object)(Stack|ArrayList|Cursor|Procedure|Predicate|OpenHashSet|ArrayDeque)(&lt;[^&gt;]+&gt;)?" 
                    replace="@{UKType}\1" />

                <!-- Replace interfaces. -->
                <replaceregex byline="false" flags="gmi" 
                    pattern="(?:Object)(Collection|Deque|Container|LookupContainer|Set|IndexedContainer)(&lt;[^&gt;]+&gt;)?" 
                    replace="@{UKType}\1" />

                <!-- Replace abstract classes. -->
                <replaceregex byline="false" flags="gmi" 
                    pattern="(?:AbstractObject)(Collection)(&lt;[^&gt;]+&gt;)?" 
                    replace="Abstract@{UKType}\1" />

                <!-- Intrinsics.equals(a, b) → (a == b) -->
                <replaceregex byline="false"  flags="gmi" 
                    pattern="(?:Intrinsics\s*\.\s*equals\()(.+?)(?:,)(.+?)(?:\))" 
                    replace="\(\1 == \2\)" />

                <!-- Replace generic argument (KType) references with the actual type. -->
                <replacestring from="&lt;KType&gt;" to="" />

                <!-- Replace hash function references. -->
                <replaceregex byline="false" flags="gmi"
                    pattern="ObjectHashFunction(&lt;[^&gt;]+&gt;)?" replace="@{UKType}HashFunction" />
                <replaceregex byline="false" flags="gmi"
                    pattern="ObjectMurmurHash(&lt;[^&gt;]+&gt;)?"   replace="@{UKType}MurmurHash" />
            </filtermapper>

            <apply.filter 
                fileset="@{fileset}"
                filter1="filter.specific.@{KType}" 
                filter2="filter.ktype.@{KType}"
                filter3="filter.common.@{KType}"
                todir="@{todir}"
            />
        </sequential>
    </macrodef>

    <macrodef name="preprocess.KTypeVType">
        <attribute name="KType" />
        <attribute name="UKType" />
        <attribute name="VType" />
        <attribute name="UVType" />
        <attribute name="fileset" />
        <attribute name="todir" />

        <sequential>
            <declare.filter.common filterName="filter.common.@{KType}@{VType}" />
            <declare.filter.ktype  filterName="filter.ktype.@{KType}@{VType}" KType="@{KType}" UKType="@{UKType}" />
            <declare.filter.vtype  filterName="filter.vtype.@{KType}@{VType}" VType="@{VType}" UVType="@{UVType}" />

            <filtermapper id="filter.specific.@{KType}@{VType}">
                <!-- Replace template class declarations in tests and benchmarks. -->
                <replaceregex byline="false" flags="gmi" 
                    pattern="(?:ObjectObject)(OpenHashMap|Cursor|Procedure|AssociativeContainer|Map)(&lt;[^&gt;]+&gt;)?" 
                    replace="@{UKType}@{UVType}\1" />

                <!-- Intrinsics.equals(a, b) → (a == b) -->
                <replaceregex byline="false"  flags="gmi" 
                    pattern="(?:Intrinsics\s*\.\s*equals\()(.+?)(?:,)(.+?)(?:\))" 
                    replace="\(\1 == \2\)" />

                <!-- Replace cursors -->
                <replaceregex byline="false" flags="gmi" 
                    pattern="(?:Object)(Cursor|Container|Predicate|Collection|Procedure|LookupContainer)(&lt;[^&gt;]+&gt;)" 
                    replace="@{UKType}\1" />

                <!-- replaceWith:genericSignature → (empty generic signature) -->
                <replaceregex byline="false" flags="gms"
                    pattern="(?:/\*\s*)(?:replaceWith:genericSignature)(.+?)(\*/)(.+?)(end:replaceWith)(\s*\*/)" 
                    replace="/* replaceWith:applied. */" />

                <!-- replaceIf:allprimitives → (empty) -->
                <replaceregex byline="false" flags="gms"
                    pattern="(?:/\*\s*)(?:replaceIf:allprimitives)(.+?)(\*/)(.+?)(end:replaceIf)(\s*\*/)" 
                    replace="/* replaceIf:applied. */" />

                <!-- Replace generic argument (KType, VType) references with the actual type. -->
                <replacestring from="&lt;KType, VType&gt;" to="" />

                <!-- Replace hash function references. -->
                <replacestring from="ObjectHashFunction" to="@{UKType}HashFunction" />
                <replacestring from="ObjectMurmurHash"   to="@{UKType}MurmurHash" />
            </filtermapper>

            <apply.filter 
                 fileset="@{fileset}"
                 filter1="filter.specific.@{KType}@{VType}" 
                 filter2="filter.ktype.@{KType}@{VType}"
                 filter3="filter.vtype.@{KType}@{VType}"
                 filter4="filter.common.@{KType}@{VType}"
                 todir="@{todir}"
             />
        </sequential>
    </macrodef>

    <macrodef name="preprocess.GenericKType">
        <attribute name="VType" />
        <attribute name="UVType" />
        <attribute name="fileset" />
        <attribute name="todir" />

        <sequential>
            <declare.filter.common filterName="filter.common.generic.@{VType}" />
            <declare.filter.vtype  filterName="filter.vtype.generic.@{VType}" VType="@{VType}" UVType="@{UVType}" />

            <filtermapper id="filter.specific.generic.@{VType}">
                <replaceregex byline="false" flags="gmi" 
                    pattern="(class|interface)(?:\s+)(?:ObjectObject)(OpenHashMap|Cursor|Procedure|AssociativeContainer|Map)(&lt;[^&gt;]+&gt;)" 
                    replace="\1 Object@{UVType}\2&lt;KType&gt;" />

                <replaceregex byline="false" flags="gmi" 
                    pattern="(?:ObjectObject)(OpenHashMap|Cursor|Procedure|AssociativeContainer|Map)(&lt;)(?!Object)([^&gt;]+)(&gt;)" 
                    replace="Object@{UVType}\1&lt;KType&gt;" />

                <replaceregex byline="false" flags="gmi" 
                    pattern="(?:ObjectObject)(OpenHashMap|Cursor|Procedure|AssociativeContainer|Map)(&lt;)(?=Object)([^&gt;]+)(&gt;)" 
                    replace="Object@{UVType}\1&lt;Object&gt;" />

                <replaceregex byline="false" flags="gmi" 
                    pattern="(?:ObjectObject)(OpenHashMap|Cursor|Procedure|AssociativeContainer|Map)" 
                    replace="Object@{UVType}\1" />
                
                <!-- replaceWith:genericSignature → KType -->
                <replaceregex byline="false" flags="gms"
                    pattern="(?:/\*\s*)(?:replaceWith:genericSignature)(.+?)(\*/)(.+?)(end:replaceWith)(\s*\*/)" 
                    replace="/* replaceWith:applied. */ &lt;KType&gt;" />
            </filtermapper>

            <apply.filter 
                 fileset="@{fileset}"
                 filter1="filter.specific.generic.@{VType}"
                 filter2="filter.vtype.generic.@{VType}"
                 filter3="filter.common.generic.@{VType}"
                 todir="@{todir}"
             />
        </sequential>
    </macrodef>

    <macrodef name="preprocess.GenericVType">
        <attribute name="KType" />
        <attribute name="UKType" />
        <attribute name="fileset" />
        <attribute name="todir" />

        <sequential>
            <declare.filter.common filterName="filter.common.@{KType}.generic" />
            <declare.filter.ktype  filterName="filter.ktype.@{KType}.generic" KType="@{KType}" UKType="@{UKType}" />

            <filtermapper id="filter.specific.@{KType}.generic">
                <!-- Replace cursors -->
                <replaceregex byline="false" flags="gmi" 
                    pattern="(?&lt;!Object)(?:Object)(Cursor|Container|Predicate|Collection|Procedure|LookupContainer)(&lt;[^&gt;]+&gt;)" 
                    replace="@{UKType}\1" />

                <!-- Intrinsics.equals(a, b) → (a == b) -->
                <replaceregex byline="false"  flags="gmi" 
                    pattern="(?:Intrinsics\s*\.\s*equals\()(.+?)(?:,)(.+?)(?:\))" 
                    replace="\(\1 == \2\)" />

                <replaceregex byline="false" flags="gmi" 
                    pattern="(class|interface)(?:\s+)(?:ObjectObject)(OpenHashMap|Cursor|Procedure|AssociativeContainer|Map)(&lt;[^&gt;]+&gt;)" 
                    replace="\1 @{UKType}Object\2&lt;VType&gt;" />

                <replaceregex byline="false" flags="gmi" 
                    pattern="(?:ObjectObject)(OpenHashMap|Cursor|Procedure|AssociativeContainer|Map)(&lt;)(?!Object)([^&gt;]+)(&gt;)" 
                    replace="@{UKType}Object\1&lt;VType&gt;" />

                <replaceregex byline="false" flags="gmi" 
                    pattern="(?:ObjectObject)(OpenHashMap|Cursor|Procedure|AssociativeContainer|Map)(&lt;)(?=Object)([^&gt;]+)(&gt;)" 
                    replace="@{UKType}Object\1&lt;Object&gt;" />

                <replaceregex byline="false" flags="gmi" 
                    pattern="(?:ObjectObject)(OpenHashMap|Cursor|Procedure|AssociativeContainer|Map)" 
                    replace="@{UKType}Object\1" />
                
                <!-- replaceWith:genericSignature → VType -->
                <replaceregex byline="false" flags="gms"
                    pattern="(?:/\*\s*)(?:replaceWith:genericSignature)(.+?)(\*/)(.+?)(end:replaceWith)(\s*\*/)" 
                    replace="/* replaceWith:applied. */ &lt;VType&gt;" />
            </filtermapper>

            <apply.filter 
                 fileset="@{fileset}"
                 filter1="filter.specific.@{KType}.generic"
                 filter2="filter.ktype.@{KType}.generic"
                 filter3="filter.common.@{KType}.generic"
                 todir="@{todir}"
             />
        </sequential>
    </macrodef>

    <!-- Process templates from a given path to another path. -->
    <macrodef name="apply.templates">
        <attribute name="singleTypePathRef" />
        <attribute name="doubleTypePathRef" />
        <attribute name="outputDir" />

        <sequential>
            <delete dir="@{outputDir}" failonerror="false" />
            <mkdir  dir="@{outputDir}" />

            <!-- Single type templates. -->
            <preprocess.KType KType="byte"   UKType="Byte"   fileset="@{singleTypePathRef}" todir="@{outputDir}" />
            <preprocess.KType KType="short"  UKType="Short"  fileset="@{singleTypePathRef}" todir="@{outputDir}" />
            <preprocess.KType KType="char"   UKType="Char"   fileset="@{singleTypePathRef}" todir="@{outputDir}" />
            <preprocess.KType KType="int"    UKType="Int"    fileset="@{singleTypePathRef}" todir="@{outputDir}" />
            <preprocess.KType KType="long"   UKType="Long"   fileset="@{singleTypePathRef}" todir="@{outputDir}" />
            <preprocess.KType KType="float"  UKType="Float"  fileset="@{singleTypePathRef}" todir="@{outputDir}" />
            <preprocess.KType KType="double" UKType="Double" fileset="@{singleTypePathRef}" todir="@{outputDir}" />

            <!-- I assume byte-key hash maps are of very limited use (you could use a table for this...), but anyway. -->
            <preprocess.KTypeVType KType="byte"   VType="byte"    UKType="Byte"   UVType="Byte"    fileset="@{doubleTypePathRef}" todir="@{outputDir}" />
            <preprocess.KTypeVType KType="byte"   VType="short"   UKType="Byte"   UVType="Short"   fileset="@{doubleTypePathRef}" todir="@{outputDir}" />
            <preprocess.KTypeVType KType="byte"   VType="char"    UKType="Byte"   UVType="Char"    fileset="@{doubleTypePathRef}" todir="@{outputDir}" />
            <preprocess.KTypeVType KType="byte"   VType="int"     UKType="Byte"   UVType="Int"     fileset="@{doubleTypePathRef}" todir="@{outputDir}" />
            <preprocess.KTypeVType KType="byte"   VType="long"    UKType="Byte"   UVType="Long"    fileset="@{doubleTypePathRef}" todir="@{outputDir}" />
            <preprocess.KTypeVType KType="byte"   VType="float"   UKType="Byte"   UVType="Float"   fileset="@{doubleTypePathRef}" todir="@{outputDir}" />
            <preprocess.KTypeVType KType="byte"   VType="double"  UKType="Byte"   UVType="Double"  fileset="@{doubleTypePathRef}" todir="@{outputDir}" />
                                                                                 
            <!-- short-X. -->                                                    
            <preprocess.KTypeVType KType="short"  VType="byte"    UKType="Short"  UVType="Byte"    fileset="@{doubleTypePathRef}" todir="@{outputDir}" />
            <preprocess.KTypeVType KType="short"  VType="short"   UKType="Short"  UVType="Short"   fileset="@{doubleTypePathRef}" todir="@{outputDir}" />
            <preprocess.KTypeVType KType="short"  VType="char"    UKType="Short"  UVType="Char"    fileset="@{doubleTypePathRef}" todir="@{outputDir}" />
            <preprocess.KTypeVType KType="short"  VType="int"     UKType="Short"  UVType="Int"     fileset="@{doubleTypePathRef}" todir="@{outputDir}" />
            <preprocess.KTypeVType KType="short"  VType="long"    UKType="Short"  UVType="Long"    fileset="@{doubleTypePathRef}" todir="@{outputDir}" />
            <preprocess.KTypeVType KType="short"  VType="float"   UKType="Short"  UVType="Float"   fileset="@{doubleTypePathRef}" todir="@{outputDir}" />
            <preprocess.KTypeVType KType="short"  VType="double"  UKType="Short"  UVType="Double"  fileset="@{doubleTypePathRef}" todir="@{outputDir}" />
                                                                                 
            <!-- char-X. -->                                                     
            <preprocess.KTypeVType KType="char"   VType="byte"    UKType="Char"   UVType="Byte"    fileset="@{doubleTypePathRef}" todir="@{outputDir}" />
            <preprocess.KTypeVType KType="char"   VType="short"   UKType="Char"   UVType="Short"   fileset="@{doubleTypePathRef}" todir="@{outputDir}" />
            <preprocess.KTypeVType KType="char"   VType="char"    UKType="Char"   UVType="Char"    fileset="@{doubleTypePathRef}" todir="@{outputDir}" />
            <preprocess.KTypeVType KType="char"   VType="int"     UKType="Char"   UVType="Int"     fileset="@{doubleTypePathRef}" todir="@{outputDir}" />
            <preprocess.KTypeVType KType="char"   VType="long"    UKType="Char"   UVType="Long"    fileset="@{doubleTypePathRef}" todir="@{outputDir}" />
            <preprocess.KTypeVType KType="char"   VType="float"   UKType="Char"   UVType="Float"   fileset="@{doubleTypePathRef}" todir="@{outputDir}" />
            <preprocess.KTypeVType KType="char"   VType="double"  UKType="Char"   UVType="Double"  fileset="@{doubleTypePathRef}" todir="@{outputDir}" />
                                                                                  
            <!-- int-X. -->                                                       
            <preprocess.KTypeVType KType="int"    VType="byte"    UKType="Int"    UVType="Byte"    fileset="@{doubleTypePathRef}" todir="@{outputDir}" />
            <preprocess.KTypeVType KType="int"    VType="short"   UKType="Int"    UVType="Short"   fileset="@{doubleTypePathRef}" todir="@{outputDir}" />
            <preprocess.KTypeVType KType="int"    VType="char"    UKType="Int"    UVType="Char"    fileset="@{doubleTypePathRef}" todir="@{outputDir}" />
            <preprocess.KTypeVType KType="int"    VType="int"     UKType="Int"    UVType="Int"     fileset="@{doubleTypePathRef}" todir="@{outputDir}" />
            <preprocess.KTypeVType KType="int"    VType="long"    UKType="Int"    UVType="Long"    fileset="@{doubleTypePathRef}" todir="@{outputDir}" />
            <preprocess.KTypeVType KType="int"    VType="float"   UKType="Int"    UVType="Float"   fileset="@{doubleTypePathRef}" todir="@{outputDir}" />
            <preprocess.KTypeVType KType="int"    VType="double"  UKType="Int"    UVType="Double"  fileset="@{doubleTypePathRef}" todir="@{outputDir}" />
                                                                                 
            <!-- long-X. -->                                                     
            <preprocess.KTypeVType KType="long"   VType="byte"    UKType="Long"   UVType="Byte"    fileset="@{doubleTypePathRef}" todir="@{outputDir}" />
            <preprocess.KTypeVType KType="long"   VType="short"   UKType="Long"   UVType="Short"   fileset="@{doubleTypePathRef}" todir="@{outputDir}" />
            <preprocess.KTypeVType KType="long"   VType="char"    UKType="Long"   UVType="Char"    fileset="@{doubleTypePathRef}" todir="@{outputDir}" />
            <preprocess.KTypeVType KType="long"   VType="int"     UKType="Long"   UVType="Int"     fileset="@{doubleTypePathRef}" todir="@{outputDir}" />
            <preprocess.KTypeVType KType="long"   VType="long"    UKType="Long"   UVType="Long"    fileset="@{doubleTypePathRef}" todir="@{outputDir}" />
            <preprocess.KTypeVType KType="long"   VType="float"   UKType="Long"   UVType="Float"   fileset="@{doubleTypePathRef}" todir="@{outputDir}" />
            <preprocess.KTypeVType KType="long"   VType="double"  UKType="Long"   UVType="Double"  fileset="@{doubleTypePathRef}" todir="@{outputDir}" />
                                                                                 
            <!-- float-X. -->                                                    
            <preprocess.KTypeVType KType="float"  VType="byte"    UKType="Float"  UVType="Byte"    fileset="@{doubleTypePathRef}" todir="@{outputDir}" />
            <preprocess.KTypeVType KType="float"  VType="short"   UKType="Float"  UVType="Short"   fileset="@{doubleTypePathRef}" todir="@{outputDir}" />
            <preprocess.KTypeVType KType="float"  VType="char"    UKType="Float"  UVType="Char"    fileset="@{doubleTypePathRef}" todir="@{outputDir}" />
            <preprocess.KTypeVType KType="float"  VType="int"     UKType="Float"  UVType="Int"     fileset="@{doubleTypePathRef}" todir="@{outputDir}" />
            <preprocess.KTypeVType KType="float"  VType="long"    UKType="Float"  UVType="Long"    fileset="@{doubleTypePathRef}" todir="@{outputDir}" />
            <preprocess.KTypeVType KType="float"  VType="float"   UKType="Float"  UVType="Float"   fileset="@{doubleTypePathRef}" todir="@{outputDir}" />
            <preprocess.KTypeVType KType="float"  VType="double"  UKType="Float"  UVType="Double"  fileset="@{doubleTypePathRef}" todir="@{outputDir}" />
                                                                                 
            <!-- double-X. -->                                                   
            <preprocess.KTypeVType KType="double" VType="byte"    UKType="Double" UVType="Byte"    fileset="@{doubleTypePathRef}" todir="@{outputDir}" />
            <preprocess.KTypeVType KType="double" VType="short"   UKType="Double" UVType="Short"   fileset="@{doubleTypePathRef}" todir="@{outputDir}" />
            <preprocess.KTypeVType KType="double" VType="char"    UKType="Double" UVType="Char"    fileset="@{doubleTypePathRef}" todir="@{outputDir}" />
            <preprocess.KTypeVType KType="double" VType="int"     UKType="Double" UVType="Int"     fileset="@{doubleTypePathRef}" todir="@{outputDir}" />
            <preprocess.KTypeVType KType="double" VType="long"    UKType="Double" UVType="Long"    fileset="@{doubleTypePathRef}" todir="@{outputDir}" />
            <preprocess.KTypeVType KType="double" VType="float"   UKType="Double" UVType="Float"   fileset="@{doubleTypePathRef}" todir="@{outputDir}" />
            <preprocess.KTypeVType KType="double" VType="double"  UKType="Double" UVType="Double"  fileset="@{doubleTypePathRef}" todir="@{outputDir}" />  
    
            <!-- KType-X (generic key). -->
            <preprocess.GenericKType VType="byte"   UVType="Byte"   fileset="@{doubleTypePathRef}" todir="@{outputDir}" />
            <preprocess.GenericKType VType="short"  UVType="Short"  fileset="@{doubleTypePathRef}" todir="@{outputDir}" />
            <preprocess.GenericKType VType="char"   UVType="Char"   fileset="@{doubleTypePathRef}" todir="@{outputDir}" />
            <preprocess.GenericKType VType="int"    UVType="Int"    fileset="@{doubleTypePathRef}" todir="@{outputDir}" />
            <preprocess.GenericKType VType="long"   UVType="Long"   fileset="@{doubleTypePathRef}" todir="@{outputDir}" />
            <preprocess.GenericKType VType="float"  UVType="Float"  fileset="@{doubleTypePathRef}" todir="@{outputDir}" />
            <preprocess.GenericKType VType="double" UVType="Double" fileset="@{doubleTypePathRef}" todir="@{outputDir}" />
    
            <!-- X-KType (generic value). -->
            <preprocess.GenericVType KType="byte"   UKType="Byte"   fileset="@{doubleTypePathRef}" todir="@{outputDir}" />
            <preprocess.GenericVType KType="short"  UKType="Short"  fileset="@{doubleTypePathRef}" todir="@{outputDir}" />
            <preprocess.GenericVType KType="char"   UKType="Char"   fileset="@{doubleTypePathRef}" todir="@{outputDir}" />
            <preprocess.GenericVType KType="int"    UKType="Int"    fileset="@{doubleTypePathRef}" todir="@{outputDir}" />
            <preprocess.GenericVType KType="long"   UKType="Long"   fileset="@{doubleTypePathRef}" todir="@{outputDir}" />
            <preprocess.GenericVType KType="float"  UKType="Float"  fileset="@{doubleTypePathRef}" todir="@{outputDir}" />
            <preprocess.GenericVType KType="double" UKType="Double" fileset="@{doubleTypePathRef}" todir="@{outputDir}" />
        </sequential>
    </macrodef>


    <!-- Generate primitive variations from main sources. -->
    <target name="generate.sources" description="Generate sources, library classes">
    	<fail unless="project.build.directory" />
    	
        <!-- Single-argument templates. -->
        <path id="KType">
            <fileset dir="${basedir}/src/main/java">
                <include name="**/ObjectArrayList*.java" />
                <include name="**/ObjectStack*.java" />
                <include name="**/ObjectCursor*.java" />
                <include name="**/ObjectProcedure*.java" />
            	<include name="**/ObjectPredicate*.java" />
                <include name="**/ObjectOpenHashSet*.java" />
                <include name="**/ObjectArrayDeque*.java" />

                <include name="**/ObjectContainer.java" />
                <include name="**/ObjectDeque.java" />
                <include name="**/ObjectLookupContainer.java" />
                <include name="**/ObjectCollection.java" />
                <include name="**/ObjectSet.java" />
                <include name="**/ObjectIndexedContainer.java" />

                <include name="**/AbstractObjectCollection.java" />
            </fileset>
        </path>

        <!-- Double-argument templates. -->
        <path id="KTypeVType">
            <fileset dir="${basedir}/src/main/java">
                <include name="**/ObjectObjectOpenHashMap*.java" />
                <include name="**/ObjectObjectCursor.java" />
                <include name="**/ObjectObjectProcedure.java" />
                <include name="**/ObjectObjectAssociativeContainer.java" />
                <include name="**/ObjectObjectMap.java" />
            </fileset>
        </path>

        <apply.templates
            singleTypePathRef="KType"
            doubleTypePathRef="KTypeVType"
            outputDir="${project.build.directory}/generated-sources/main/java" />
    </target>

    <!-- Generate primitive variations from test sources. -->
    <target name="generate.test.sources" description="Generate sources, test classes">
    	<fail unless="project.build.directory" />

        <!-- Single-argument templates. -->
        <path id="KType">
            <fileset dir="${basedir}/src/test/java">
                <include name="**/ObjectArrayList*.java" />
                <include name="**/ObjectStack*.java" />
                <include name="**/ObjectOpenHashSet*.java" />
                <include name="**/ObjectArrayDeque*.java" />
            </fileset>
        </path>

        <!-- Double-argument templates. -->
        <path id="KTypeVType">
            <fileset dir="${basedir}/src/test/java">
                <include name="**/ObjectObjectOpenHashMapTest.java" />
            </fileset>
        </path>

        <apply.templates
            singleTypePathRef="KType"
            doubleTypePathRef="KTypeVType"
            outputDir="${project.build.directory}/generated-sources/test/java" />
    </target>
    
    <target name="-dummy">
        <echo>Use Maven to generate/compile sources.</echo>
    </target>
</project>
