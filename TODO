
Ideas:


- addAll(Set), retainAll(Set) and removeAll(Set) are crucial for a set, I'd add them
starting from the first release, even with a generic (and possibly inefficient) 
implementation.

I don't want to use interfaces, to be honest. I'd lean towards overloaded static utility
methods (compile-time binding). See note below too.


- A use case from Lingo3G for a Map: add some value to the value held at a specific key.
Obviously, this could be done as a sequence of set(key, get(key) + val), but then the
hash key needs to be computed twice (this actually makes quite a difference for
Lingo3G language recognizer speed). We could use slotFor() as well, but this is really 
low-level and the users of the library would have to fiddle a lot with the other 
(exposed) internals like the states array (leading to errors and increased traffic 
on the mailing list :-). One elegant solution would be to define an ObjectFunction 
interface with apply() taking one argument and returning the results. Not sure about 
the performance of this pattern; it is used in Colt though, which was meant for high 
performance computation.

[REPLY] There is nothing wrong in using the internals of these classes, that's the reason
I want them open. If you encapsulate, you'll end up having java.util.HashMap... This
adds something to the entire collection, for example: 

for (IntLongCursor c : map) {
  map.values[c.index] += value;
}

Is this really so bad? I don't think so. Of course closure-like interfaces are fine, 
but we also need to make sure they're not the only way to use this library (an anonymous
class takes place and its object still needs to be created). I'd have nothing against
things like this, for example:

if (map.hasKey(key))
  map.lset(map.lget() + val);

The alternative you suggest, as far as I understand:

map.apply(key, new IntFunction() {
   public int apply(int v) {
     return v + val;
   }
});

if val is a local, then it'd have to be passed through synthetic constructor, not too 
nice. 

I'm also thinking -- we could move these high-level interfaces to a separate class and
then have any kind of meta-ways of accessing collection classes. Similar to what Google
Guava has (Functions., Predicates.). A set of static classes with overloaded parameters
and efficient implementations inside would then be possible.
 